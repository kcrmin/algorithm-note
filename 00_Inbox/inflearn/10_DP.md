---
deprecated: true
note: "Inbox 정리용 노트 (deprecated)"
---

# 섹션 10 - Dynamic Programming (DP)

## 1. LIS (Longest Increasing Subsequence)

```java
import java.util.*;

public class Main {
    static int lis(int[] arr) {
        int result = 0;
        int n = arr.length;
        int[] dp = new int[n + 1];     // dp[i] = i에서 끝나는 LIS 길이
        Arrays.fill(dp, 1);        // 자기 자신만 포함하면 길이 1

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[j] < arr[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            result = Math.max(result, dp[i]);
        }

        return result;
    }
}
```
> `dp[i]` = i번째 원소로 끝나는 LIS 길이
> 
> 모든 j<i 중 `arr[j] < arr[i]` 조건이면 후보
> 
> 최종 답은 dp 배열의 최댓값


## 2. 냅색(Knapsack) 알고리즘

### ✔ 핵심 규칙
1. **무한이면 앞 → 뒤**
2. **유한이면 뒤 → 앞**
3. **최대면 max, 최소면 min**
4. **최소 DP는 INF로 초기화 (오버플로우 주의)**

### 2-1. 무한 냅색 (Unbounded)

```java
import java.util.*;

public class Main {
    public static int unboundedKnapsack(int target, int[] items) {
        int[] dp = new int[target + 1];
        Arrays.fill(dp, Integer.MAX_VALUE); // MAX Value 조심하기!!!
        dp[0] = 0;

        for (int item : items) {
            for (int i = item; i <= target; i++) {
                if (dp[i - item] != Integer.MAX_VALUE) dp[i] = Math.min(dp[i], dp[i - item] + 1);
            }
        }

        return dp[target];
    }
}
```
> `for (int i = item; i <= target; i++)` 같은 물건을 여러 번 사용할 수 있도록 함
> 
> `+ 1`은 값을 추가 (상황에 따라 다른 값 추가)

### 2-2. 유한 냅색 (0/1 Knapsack)

```java
import java.util.*;

public class Main {
    public static int solution(int target, int[] items) {
        int[] dp = new int[target + 1];

        for (int item : items) {
            for (int i = target; i >= item; i--) {
                dp[i] = Math.max(dp[i], dp[i - item] + 1);
            }
        }

        return dp[target];
    }
}
```
> `for (int i = target; i >= item; i--)` 물건을 한번만 사용할 수 있도록 함
> 
> `+ 1`은 값을 추가 (상황에 따라 다른 값 추가)


## 3. 주의 포인트
|  코드 / 개념  | 요약                                               |
|:---------:|:-------------------------------------------------|
| DP 초기값 설정 | 문제에 맞게 초기값 선택해야 함. 경우에 따라 0 / 1 / INF 등 달라질 수 있음 |
| 최소 비용 DP  | INF로 초기화 + INF + cost 오버플로우 주의 (long 권장)         |
| 무한/유한 냅색  | 무한: 앞→뒤, 유한: 뒤→앞 반드시 구분                          |
|    자료형    | 경우의 수 문제는 int 오버플로우 → long 또는 mod 사용             |


## **핵심 요약**
- DFS/BFS보다 **중복 계산 제거**
- 효율적으로 최적해 도출
- 상태를 저장해 시간 단축

## 문제 다시 풀기
### **[Inflearn](../../src/inflearn/section10_dp)**
| 분류 | 문제 이름                                                                       | 포인트 메모   |
|:--:|:----------------------------------------------------------------------------|:---------|
| 기초 | [10-01 계단오르기](../../src/inflearn/section10_dp/INF_S10_P01.java)             | 피보나치 수열  |
| 기초 | [10-03 최대 부분 증가수열](../../src/inflearn/section10_dp/INF_S10_P03.java)        | LIS 알고리즘 |
| 기초 | [10-05 동전교환(냅색 알고리즘)](../../src/inflearn/section10_dp/INF_S10_P05.java)     | 무한 냅색    |
| 기초 | [10-06 최대점수 구하기(냅색 알고리즘)](../../src/inflearn/section10_dp/INF_S10_P06.java) | 유한 냅색    |